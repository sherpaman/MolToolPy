import re
import gro
import numpy
import scipy.stats

#REGULAR EXPRESSION DEFINITIONS
re_nucleotide=re.compile('D[ATCG][0-9]+')
re_protein=re.compile('[A-Z]{3}[0-9]+')

def is_water(name):
	return (name[:3]=="WAT")|(name[:3]=="SOL")|(name[:3]=="HOH")

def is_nucleotide(name):
	return (name[0]=="D")

def residue_split(name,m):
	return m.find_atom_res(name)

def uniq(list):
	checked=[]
	for i in list:
		if i not in checked:
			checked.append(i)
	return checked

def fscore(p1,p2,t1,t2):
	n1=int(p1*t1/100.0)+1
	n2=int(p2*t2/100.0)+1
	odds, pvalue = scipy.stats.fisher_exact([ [ n1 , (t1 - n1)+1 ], [ n2, (t2 - n2)+1 ] ])
	#print "F-SCORE [ [ %d , %d ], [ %d, %d] ] = %f" %(n1 , (t1 - n1)+1 ,  n2 , (t2 - n2)+1, pvalue )
	return pvalue

class hbond:
	def __init__(self,don=['res1',0],don_atom='',acc=['res2',0],acc_atom='',h='',perc=0.0,mediated=0.0,both=0.0,nfr=0):
		self.acc=acc
		self.acc_atom=acc_atom
		self.don=don
		self.don_atom=don_atom
		self.perc=perc
		self.mediated=mediated
		self.both=both
		self.nfr=nfr
	
	#def __setattr__(self,name,value):
		#if (name=='don')|(name=='acc'):
			#self.__dict__[name]=list(value)
		#else:
			#self.__dict__[name]=value
	
	def __str__(self):
		return "%11s %11s %6.2f %6.2f %6.2f %d \n" %(self.don[0]+str(self.don[1])+str(self.don_atom),self.acc[0]+str(self.acc[1])+str(self.acc_atom),self.perc,0.0,0.0,self.nfr)
	
	def __repr__(self):
		print str(self)
	
	def renum(self,func):
		self.don[1]=func(self.don[1])
		self.acc[1]=func(self.acc[1])
	
	def is_same_couple(self,other):
		return (self.acc==other.acc)&(self.don==other.don)
	
	def fscore(self,other):
		n1=int(self.perc*self.nfr/100.0)
		n2=int(other.perc*other.nfr/100.0)
		odds, pvalue = scipy.stats.fisher_exact([ [ n1 , perc*self.nfr - n1 ],[ n2 , perc*other.nfr - n2 ] ])
		return pvalue

class hbonds:
	def __init__(self,name='New List',hblist=[],nfr=0,mol=gro.molecule()):
		self.name=name		
		self.hblist=[]
		self.nbonds=len(self.hblist)
		self.nfr=nfr
		self.names=dict()
		self.mol=mol
	
	def __str__(self):
		out=self.name+'\n'
		for i in self.hblist:
			out = out + str(i)
		return out
	
	def __repr__(self):
		print self.name
		for i in self.hblist:
			print i
	
	def residue_split(self,name):
		return self.mol.find_atom_res(name)
	
	def renum(self,func):
		for hb in self.hblist:
			hb.renum(func)
	
	def refresh(self):
		self.nbonds=len(self.hblist)
		self.create_names()
		
	def write_file(self,filename):
		out=open(filename,'w')
		out.write(self.name+'\n')
		for i in self.hblist:
			out.write(str(i))
		out.close()
	
	def read_log_red(self,filein,filegro):
		"""
		Populate the hbonds object with the hbond found in a
		file .log generated by g_hbond [-g] 
		
		"""
		fi=open(filein,'r')
		self.mol=gro.read_gro(filegro)
		raw_fi=fi.readline()
		self.name=filein
		n_hb=0
		while raw_fi:
			#
			# Exlude the comment lines and with less than 3 field
			#
			if (raw_fi.split()[0] != '#')&(len(raw_fi.split())>2):
				donor   = raw_fi.split()[0]
				hydrogen= raw_fi.split()[1]
				acceptor= raw_fi.split()[2]
				#
				# Extract the residue name, including the number
				#
				don_res=self.mol.find_atom_res(donor)
				acc_res=self.mol.find_atom_res(acceptor)
				#if is_nucleotide(donor):
				#	don_res=re_nucleotide.findall(donor)[0]
				#else:
				#	don_res=re_protein.findall(donor)[0]
				#if is_nucleotide(acceptor):
				#	acc_res=re_nucleotide.findall(acceptor)[0]
				#else:
				#	acc_res=re_protein.findall(acceptor)[0]
				#
				# Based on the number of charachters in the residue name
				# extract the atom name [For future uses]
				#
				don_atom=self.mol.find_atom_name(donor)
				acc_atom=self.mol.find_atom_name(acceptor)
				
				self.hblist.append(hbond(don=don_res,don_atom=don_atom, acc=acc_res,acc_atom=acc_atom, perc=0.0, mediated=0.0, both=0.0,nfr=self.nfr))
				
				n_hb += 1
			raw_fi=fi.readline()
		fi.close()
	
	def read_log(self,filein,filegro):
		"""
		Populate the hbonds object with the hbond found in a
		file .log generated by g_hbond [-g] merging the bonds
		for the same residue couple 
		
		returns 3 objects:
			list_hb : a list of unique hbons in the format 
				[ ... [don_res, acc_res] ... ]
			
			redundant_list_hb : the list of all hbonds found in the .log
			
			refernce_hb : a reference list between redundant_list_hb 
				and list_hb
		"""
		fi=open(filein,'r')
		self.mol=gro.read_gro(filegro)
		print self.mol
		#for r in self.mol.residues:
		#	print r.num, r
		#print self.mol
		raw_fi=fi.readline()
		list_hb=[]
		reference_hb=[]
		redundant_list_hb=[]
		self.name=filein
		n_hb=0
		n=0
		while raw_fi:
			#
			# Exlude the comment lines and with less than 3 field
			#
			if (raw_fi.split()[0] != '#')&(len(raw_fi.split())>2):
				#n+=1
				#print n, raw_fi
				donor   = raw_fi.split()[0]
				hydrogen= raw_fi.split()[1]
				acceptor= raw_fi.split()[2]
				#
				# Extract the residue name, including the number
				#
				don_res=self.mol.find_atom_res(donor)
				acc_res=self.mol.find_atom_res(acceptor)
				#if is_nucleotide(donor):
				#	don_res=re_nucleotide.findall(donor)[0]
				#else:
				#	don_res=re_protein.findall(donor)[0]
				#if is_nucleotide(acceptor):
				#	acc_res=re_nucleotide.findall(acceptor)[0]
				#else:
				#	acc_res=re_protein.findall(acceptor)[0]
				#
				# Based on the number of charachters in the residue name
				# extract the atom name [For future uses]
				#
				don_atom=self.mol.find_atom_name(donor)
				acc_atom=self.mol.find_atom_name(acceptor)
				#
				# Object that will be screened for insertion in the uniqe list
				#
				#print don_res, acc_res
				new_hb=[don_res[0]+"_"+str(don_res[1]),acc_res[0]+"_"+str(acc_res[1])]
				#
				# No screening is needed for the redundand list
				# 
				redundant_list_hb.append([donor,hydrogen,acceptor])
				#
				# Screen for hbond not already found
				#
				if new_hb not in list_hb:
					# New Hbond found!
					list_hb.append(new_hb)
					reference_hb.append([n_hb])
					# Populating the hbonds object !
					self.hblist.append(hbond(don=don_res, acc=acc_res, perc=0.0, mediated=0.0, both=0.0,nfr=self.nfr))
				else:
					# Old Hbond found, only reference to the
					# unique list is needed
					reference_hb[list_hb.index(new_hb)].append(n_hb)
				n_hb += 1
			raw_fi=fi.readline()
		fi.close()
		return list_hb, redundant_list_hb, reference_hb 
	
	def read_file_perc(self,filein,filegro):
		"""
			Populates the hbonds object using a percentage file already
			generated.
			
			Only the uncommented lines including 6 fields will be read
			
			The format of the file should be the following:
			
			Donor     Acceptor      Direct   Mediated       Both      Total Frames
			RES999    RES000         99.99      33.33      66.66       9999
			
		"""
		fi=open(filein,'r')
		self.mol=gro.read_gro(filegro)
		raw_fi=fi.readline()
		n=0
		while raw_fi:
			line=raw_fi.split()
			if ( len(line) == 6):
				if ( line[0] != '#' ):
					n+=1
					t_don=self.mol.split_res(line[0])
					t_acc=self.mol.split_res(line[1])
					#print t_acc, t_don
					t_perc=float(line[2])
					t_nfr=int(line[5])
					self.hblist.append(hbond(acc=t_acc,don=t_don,perc=t_perc,nfr=t_nfr))
			raw_fi=fi.readline()
		print "read %d lines from file %s %d frames" %(n,filein,t_nfr)
		fi.close()
		self.refresh()
	
	def read_file_perc_red(self,filein,filegro):
		"""
			Populates the hbonds object using a percentage file already
			generated.
			
			Only the uncommented lines including 6 fields will be read
			
			The format of the file should be the following:
			
			Donor       Acceptor          Direct   Mediated       Both      Total Frames
			RES999NAME  RES000NAME         99.99      33.33      66.66       9999
			
		"""
		fi=open(filein,'r')
		self.mol=gro.read_gro(filegro)
		raw_fi=fi.readline()
		n=0
		while raw_fi:
			line=raw_fi.split()
			if ( len(line) == 6):
				if ( line[0] != '#' ):
					n+=1
					t_don=self.mol.find_atom_res(line[0])
					t_acc=self.mol.find_atom_res(line[1])
					don_atom=self.mol.find_atom_name(line[0])
					acc_atom=self.mol.find_atom_name(line[1])
					#print t_acc, t_don
					t_perc=float(line[2])
					t_nfr=int(line[5])
					self.hblist.append(hbond(acc=t_acc,acc_atom=acc_atom,don=t_don,don_atom=don_atom,perc=t_perc,nfr=t_nfr))
			raw_fi=fi.readline()
		print "read %d lines from file %s %d frames" %(n,filein,t_nfr)
		fi.close()
		self.refresh()
	
	def create_names(self):
		self.names=dict()
		for i in self.hblist:
			#print i.acc, i.don
			self.names[i.acc[1]]=i.acc[0]
			self.names[i.don[1]]=i.don[0]
	
	def list_acc(self):
		list_out=[]
		for i in self.hblist:
			list_out.append(i.acc)
		return uniq(list_out)
	
	def list_acc_n(self):
		list_out=[]
		for i in self.hblist:
			list_out.append(i.acc[1])
		return uniq(list_out)
	
	def list_don(self):
		list_out=[]
		for i in self.hblist:
			list_out.append(i.don)
		return uniq(list_out)
	
	def list_don_n(self):
		list_out=[]
		for i in self.hblist:
			list_out.append(i.don[1])
		return uniq(list_out)
	
	def list_res(self):
		return uniq(self.list_acc()+self.list_don())
	
	def list_res_n(self):
		return uniq(self.list_acc_n()+self.list_don_n())
	
	def merge_acc(self, other):
		return uniq(self.list_acc()+other.list_acc())
	
	def merge_acc_n(self, other):
		return uniq(self.list_acc_n()+other.list_acc_n())
	
	def merge_don(self, other):
		return uniq(self.list_don()+other.list_don())
	
	def merge_don_n(self, other):
		return uniq(self.list_don_n()+other.list_don_n())
	
	def merge_res(self, other):
		return uniq(self.list_res()+other.list_res())
	
	def merge_res_n(self, other):
		return uniq(self.list_res_n()+other.list_res_n())
	
def merge_two(first, second):
	"""
		Merge two hbonds object by performing the weightd averages
		based on the number of number of frames (self.nfr)
	"""
	merged=hbonds()
	check2=numpy.zeros(len(second.hblist),dtype=int)
	for hb1 in first.hblist:
		check_is_same_couple=0
		for n2,hb2 in enumerate(second.hblist):
			if hb1.is_same_couple(hb2):
				check_is_same_couple=1
				check2[n2]=1
				merged.hblist.append(hbond(acc=hb1.acc,don=hb1.don,perc=(hb1.perc*hb1.nfr+hb2.perc*hb2.nfr)/float(hb1.nfr+hb2.nfr),nfr=hb1.nfr+hb2.nfr))
				break
		if check_is_same_couple==0:
			merged.hblist.append(hbond(acc=hb1.acc,don=hb1.don,perc=float(hb1.perc*hb1.nfr)/float(hb1.nfr+hb2.nfr),nfr=hb1.nfr+hb2.nfr))
	for n2, hb2 in enumerate(second.hblist):
		if check2[n2]==0:
			check2[n2]=1
			merged.hblist.append(hbond(acc=hb2.acc,don=hb2.don,perc=float(hb2.perc*hb2.nfr)/float(hb1.nfr+hb2.nfr),nfr=hb1.nfr+hb2.nfr))
	merged.refresh()
	return merged

class hbcomp:
	def __init__(self,don=['res1',0],acc=['res2',0],perc1=0.0,perc2=0.0,nfr1=0,nfr2=0,fisher=None):
		self.acc=acc
		self.don=don
		self.perc1=perc1
		self.perc2=perc2
		self.nfr1=nfr1
		self.nfr2=nfr2
		self.fisher=fisher
	
	def __str__(self):
		return "%3s | %4d | %3s | %4d | %6.2f  | %6.2f  | %12.10f\n" %(self.don[0],self.don[1],self.acc[0],self.acc[1],self.perc1,self.perc2,self.fisher)
	
	def __repr__(self):
		print "%3s | %4d | %3s | %4d | %6.2f  | %6.2f  | %12.10f " %(self.don[0],self.don[1],self.acc[0],self.acc[1],self.perc1,self.perc2,self.fisher)
	
	def renum(self,func):
		self.don[1]=func(self.don[1])
		self.acc[1]=func(self.acc[1])

class hbonds_compare:
	"""
		This Class can be used to do comparison between two hbonds object
		
	"""
	def __init__(self,first=hbonds(),second=hbonds()):
		self.first=first
		self.second=second
		self.don=self.first.merge_don(self.second)
		self.acc=self.first.merge_acc(self.second)
		#self.res=self.first.merge_res(self.second)
		self.acc_n=self.first.merge_acc_n(self.second)
		self.don_n=self.first.merge_don_n(self.second)
		#self.res_n=self.first.merge_res_n(self.second)
		#
		# Matrix M1 and M2 will contain the data of percentage of existance
		# and the nfr of the thwo hbonds objects
		#
		self.M1=numpy.zeros([len(self.don_n),len(self.acc_n),2])
		self.M2=numpy.zeros([len(self.don_n),len(self.acc_n),2])
		#
		# Matrix E is a binary matrix for internal use:
		# E[i,j] == 1  if a hbond between i an j exists.
		#
		self.E =numpy.zeros([len(self.don_n),len(self.acc_n)],dtype=int)
		#
		# Matrix F contains the Fisher scores of the difference of percentage
		# F[i,j] = Fisher_Score( M1[i,j], M2[i,j] )
		#
		self.F =numpy.zeros([len(self.don_n),len(self.acc_n)])
		self.compare=[]
	
	def __str__(self):
		out="%3s | %4s | %3s | %4s | %6s  | %6s  | %10s\n" %('Don','#','Acc','#','Perc.1','Perc.2','Fisher-Score')
		for hb in self.compare:
			out=out+str(hb)
		return out
	
	def __repr__(self):
		print "%3s | %4s | %3s | %4s | %6s  | %6s  | %10s" %('Don','#','Acc','#','Perc.1','Perc.2','Fisher-Score')
		for hb in self.compare:
			print hb
	
	def renum(self,func):
		"""
			Permits to renumber the residues using a user-defined function
		"""
		for hb in self.compare:
			hb.renum(func)
	
	def do_comparison(self,perc=0.0,verbose=False):
		"""
			After creating the object, this function permits to actually
			perform a comparison.
			
			In the current version only the Exact-Fisher score for the 
			evaluation of significance of the differences is implemented. 
		"""
		for i in range(self.first.nbonds):
			self.M1[self.don_n.index(self.first.hblist[i].don[1]),self.acc_n.index(self.first.hblist[i].acc[1]),0]  = self.first.hblist[i].perc
			self.M1[self.don_n.index(self.first.hblist[i].don[1]),self.acc_n.index(self.first.hblist[i].acc[1]),1]  = self.first.hblist[i].nfr
			self.E [self.don_n.index(self.first.hblist[i].don[1]),self.acc_n.index(self.first.hblist[i].acc[1])] += 1
		for i in range(self.second.nbonds):
			self.M2[self.don_n.index(self.second.hblist[i].don[1]),self.acc_n.index(self.second.hblist[i].acc[1]),0]  = self.second.hblist[i].perc
			self.M2[self.don_n.index(self.second.hblist[i].don[1]),self.acc_n.index(self.second.hblist[i].acc[1]),1]  = self.second.hblist[i].nfr
			self.E [self.don_n.index(self.second.hblist[i].don[1]),self.acc_n.index(self.second.hblist[i].acc[1])] += 1
		for d in numpy.arange(len(self.don_n)):
			for a in numpy.arange(len(self.acc_n)):
				if (self.E[d,a]!=0)&((self.M1[d,a,0]>perc)|(self.M2[d,a,0]>perc)):
					if verbose:
						print " [%d,%d] F-score: fscore(%5.2f,%5.2f,%d,%d)" %(d,a,self.M1[d,a,0],self.M2[d,a,0],self.first.hblist[0].nfr,self.second.hblist[0].nfr)
					self.F[d,a] = fscore(self.M1[d,a,0],self.M2[d,a,0],self.first.hblist[0].nfr,self.second.hblist[0].nfr)
					#print a,d,self.F[a,d]
					self.compare.append(hbcomp(acc=self.acc[a],don=self.don[d],perc1=self.M1[d,a,0],nfr1=self.M1[d,a,1],perc2=self.M2[d,a,0],nfr2=self.M2[d,a,1],fisher=self.F[d,a]))
